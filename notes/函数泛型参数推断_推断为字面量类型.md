如果函数得参数通过泛型指定，在传递参数时，泛型会被自动推断。请看下面得例子：

```ts
function fun<Type>(arg: Type) {

}

fun('1')
// fun<string>(arg: string): void

fun(1)
// fun<number>(arg: number): void

fun(Symbol())
// fun<symbol>(arg: symbol): void
```

传入得参数为`'1'`时，即，`string`类型，`Type`就被推断为`string`；同理，传入`1`时，被推断为`number`。

## 通过extends限制参数类型时，泛型可被推断为更具体的类型

现在，我们用`extends`对`Type`进行类型得限制：

```ts
function fun<Type extends string | number | symbol | object | boolean>(arg: Type) {

}

fun('1')
// fun<"1">(arg: "1"): void

fun(1)
// fun<1>(arg: 1): void

fun(true)
// fun<true>(arg: true): void

fun({ a: '1', b: 1, c: { d: true } })
//function fun<{
//   a: string;
//   b: number;
//   c: {
//       d: boolean;
//   };
// }>(arg: {
//   a: string;
//   b: number;
//   c: {
//       d: boolean;
//   };
// }): void

fun(Symbol())
// fun<symbol>(arg: symbol): void
```

对于上面的例子，如果函数参数是一个泛型，且使用`extends`限制了类型，可以得出一些结论：

- 传入的字符串，数字，布尔值都被直接推断成传入的字面量类型，而不是`string`，`number`和`boolean`。
- 对象类型会被推断成`typeof arg`
- `symbol`仍然时`symbol`

使用场景：[Chainable](https://github.com/type-challenges/type-challenges/blob/main/questions/00012-medium-chainable-options/README.md)

```ts
declare const config: Chainable

const result = config
  .option('foo', 123)
  .option('name', 'type-challenges')
  .option('bar', { value: 'Hello World' })
  .get()

// expect the type of result to be:
interface Result {
  foo: number
  name: string
  bar: {
    value: string
  }
}
```

我们要实现的就是`Chainable`这个类型，我们一步一步实现：

首先，它有两个方法，`option`和`get`，先对这两个方法做个简单的声明：

```ts
interface Chainable {
    option(key: string, value: any): any;
    get(): any;
}
```

因为`option`可以链式的调用，所以，`option`方法的返回值，仍然是一个`Chainable`对象：

```ts
interface Chainable {
    option(key: string, value: any): Chainable;
    get(): any;
}
```

现在，我们来处理`get`方法的返回值。

因为`option`返回的是一个`Chainable`，这个被返回的`Chianable`之中有一个`get`方法，可以给这个`Chinable`指定一个泛型，`get`返回这个泛型：

```ts
interface Chainable<Options extends object> {
    option(key: string, value: any): Chainable;
    get(): Options;
}
```

现在，要回过头来处理`option`方法的返回值了，给这个返回值中的`Chainable`指定泛型参数，可以通过`&`把`Options`和`option`指定的键值对构成的对象组合来：

```ts
interface Chainable<Options extends object> {
    option(key: string, value: any): Chainable<Options & {???}>;
    get(): Options;
}
```

问题来了，上面`???`的部分怎么填？`{ key: value }`不可以，`option`方法并不是添加一个键为`key`的`prop`，这个键应该是`key`的值，而不是`key`本身。

这里就要用到我们上面说的知识了，我们可以把`key`声明成一个泛型，这样，在传入字符串`key`之后，泛型就被推断成`key`的值的字面量，然后用`in`就可以声明一个`Mapped Type`。

```ts
interface Chainable<Options extends object> {
  option<
    KeyType extends string,
    ValType extends any
  >(key: KeyType, value: ValType):
  Chainable<Options & {
    [props in KeyType]: ValType
  }>;
  
  get(): Options;
}
```

如果我们调用`option('name', 'hello')`

1. `KeyType`被推断为字面量类型`'name'`，`ValType`被推断为`string`

2.  `{ [props in KeyType]: ValType }`被展开为`{ 'name': string }`

3. 最终，返回`Chainable`的类型参数为：配置前的类型（即`Options`）和`option`参数键值对构成的类型的交叉类型。

关于泛型被推断成字面量的部分，已经解释完了，但是这道题目还没有完成，如果有兴趣的话可以接着看。



回头看一下单元测试，发现这个时候，有报错信息：

```ts
declare const a: Chainable
// Generic type 'Chainable<Options>' requires 1 type argument(s).
```

报错是因为这里没有给`Chainable`指定参数，因此，在声明`Chinable`时，可以指定一个默认参数：

```ts
interface Chainable<Options extends object = {}>
```

再回头看单元测试，还有问题：

```ts
  .option('name', 'another name')
  // @ts-expect-error
  .option('name', 'last name')
```

这里对`name`重复配置，这里希望进行一次报错，我们只需要判断当前配置中，是否已经有了`key`指定的`prop`：

```ts
interface Chainable<Options extends object = {}> {
  option<
    KeyType extends string,
    ValType extends any
  >
  (
    key: KeyType extends keyof Options ? never : KeyType,
    value: ValType
  ):
  Chainable<Options & {
    [props in KeyType]: ValType
  }>;
  
  get(): Options;
}
```

通过`key: KeyType extends keyof Options`判断`Options`是否已经有了键为`KeyType`的`prop`，如果已经有了，指定`key`的类型为`never`，这样，就会报错。



最后，还有一个错误：

```ts
const result3 = a
  .option('name', 'another name')
  // @ts-expect-error
  .option('name', 123)
  .get()

type Expected3 = {
  name: number
}
```

虽然这里`ts`报错了，但是，值相同的`key`会进行一次覆盖。可以通过`Omit`把`Options`中的`KeyType`删掉，然后再通过`&`添加新的。

```ts
interface Chainable<Options extends object = {}> {
  option<
    KeyType extends string,
    ValType extends any
  >
    (
      key: KeyType extends keyof Options ? never : KeyType,
      value: ValType
    ):
    Chainable<
      (
        KeyType extends keyof Options
        ? MyOmit<Options, KeyType> // 如果这个属性已经被设置过了 先删掉
        : Options // 没有设置过不用特殊处理
      ) & {
        [props in KeyType]: ValType
      }
    >

  get(): Options
}
```