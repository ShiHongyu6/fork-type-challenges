## 类似JavaScript字符串模板的用法

在`JavaScript`中，除了使用`"+"`拼接字符串，目前更推荐的做法是使用字符串模板进行插值。

在`TypeScript`中，字符串字面量类型，和字符串很像：

```ts
const a = 'Hello'

type  a = 'Hello'
```

而且，字符串字面量类型，也可以通过模板进行拼接：

```ts
type a = 'Hello'

type b = 'world'

type c = `${a} ${b}`
// type c = 'hello world'
```

## 模板+infer可以用来“取出”字符

举个例子[Capitalize](https://github.com/type-challenges/type-challenges/blob/main/questions/00110-medium-capitalize/README.md)

```ts
type capitalized = MyCapitalize<'hello world'> // expected to be 'Hello world'
```

即，要把一个字符串字面量类型的第一个字母变成大写字母。

参数分析：接收一个字符串字面量类型

```ts
MyCapitalize<S extends string>
```

实现：取出第一个字符，然后用`UpperCase`变成大写，最后再用模板拼接：

```ts
type MyCapitalize<S extends string> =
    S extends `${infer first}${infer res}`
    ? `${Uppercase<first>}${res}`
    : S
```

1. 通过条件类型进行推断，取出第一个字符

2. 通过`Uppercase`将第一个字符转换成大写

3. 通过模板拼接转换后的大写字母以及剩余的字母

## 递归+模板+infer用来“遍历”字符串字面量类型

举例[TrimLeft](https://github.com/type-challenges/type-challenges/blob/main/questions/00106-medium-trimleft/README.md)

```ts
type trimed = TrimLeft<'  Hello World  '> // expected to be 'Hello World  '
```

即，要把字面量左边的空格`space`，回车换行`"\n"`以及制表符`"\t"`都删掉。

这时候就要通过递归进行遍历：

1. 取出字符串`S`第一个字符`first`以及剩余的字符串`res`

2. `first`是否为空格、回车换行或制表符？
   
   - 是。将`res`赋值给`S`，回到`1`
   
   - 否。当前字符串`S`左边已经没有空格、回车换行和制表符。

```ts
type space = ' ' | '\n' | '\t'

type TrimLeft<S extends string> =
    S extends `${infer first}${infer res}` // 取出第一个字符
    ? first extends space // 判断第一个字符是否需要删除
      ? TrimLeft<res> // 递归调用
      : S // 如果第一个字符不需要删除 说明已经删完了 返回S
    : S // 如果是一个空串''，第一步推断的时候就会进入这个分支 返回S，即空串

```

上面的代码还可以进行优化，直接在第一步推断的时候，就指定第一个字符，如果推断成功，则说明需要删除，否则，直接返回：

```ts
type space = ' ' | '\n' | '\t'

type TrimLeft<S extends string> =
    S extends `${space}${infer res}` // 推断第一个字符为空格
    ? TrimLeft<res> // 第一个字符是空格 后面的参数作为字符串递归调用
    : S // 第一个字符不为空格 直接返回
```

有了上面的例子，很容易完成另一道题目[TrimRight](https://github.com/type-challenges/type-challenges/blob/main/questions/04803-medium-trim-right/README.md)

```ts
type space = ' ' | '\n' | '\t'

type TrimRight<S extends string> =
    S extends `${infer pre}${space}`
    ? TrimRight<pre>
    : S
```

结合上面两个例子，完成另一道题目[Trim](https://github.com/type-challenges/type-challenges/blob/main/questions/00108-medium-trim/README.md)

```ts
type Trim<S extends string> = TrimRight<TrimeLeft<S>>
```


