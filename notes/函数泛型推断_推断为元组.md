如果想要声明一个函数，它接收一个元组，返回值的类型仍然是这个元组的类型，我们很容易给出它的定义：

```ts
declare function fun<Tuple extends readonly unknown[]>(arg: Tuple): Tuple
```

现在试着调用一下这个函数，看它的类型推断是否正确：

```ts
declare function fun<Tuple extends readonly unknown[]>(arg: Tuple): Tuple

fun([1, '2', true] as const)
// function fun<readonly [1, "2", true]>(tuple: readonly [1, "2", true]): readonly [1, "2", true]
```

注意，因为这里要传入的是元组，所以需要使用`as const`来标明这个数组是一个元组，如果不使用这个类型断言，类型推断就会有问题：

```ts
fun([1, '2', true])
// function fun<(string | number | boolean)[]>(arg: (string | number | boolean)[]): (string | number | boolean)[]
```

从上面这两个例子，可以总结出一个结论，类型推导的过程为：

1. 求出参数的泛型类型，`Tuple = typeof tuple`

2. 通过泛型的定义，判断是否满足`extends`的限制



先来验证一下第一步：

```ts
const array      = [1, '2', true];
const tupleArray = [1, '2', true] as const;

type t1 = typeof array;
// type t1 = (string | number | boolean)[]

type t2 = typeof tupleArray;
// type t2 = readonly [1, '2', ture]
```

和上面推导出来的`Tuple`类型是一样的。



再来验证第二步：

```ts
declare function fun<Tuple extends unknown[]>(tuple: Tuple): Tuple

fun([1, '2', true] as const)
// error:  The type 'readonly [1, "2", true]' is 'readonly' and cannot be assigned to the mutable type 'unknown[]'
```

修改泛型的限制为`unknow[]`（去掉了`readonly`），这里会报错，一个`readonly`数组无法赋值给非`readonly`的数组。



## 把普通数组推断成元组

上面说的例子显然不能满足我们的需求，假如说，我们变更一下需求，传入的参数仍然是`[1, '2', true]`但是，在类型推断时，需要推断成`[number, string, boolean]`的元组，这个时候，就需要下面的写法：

```ts
declare function fun<Tuple extends unknown[]>(tuple: readonly [...Tuple]): Tuple
```

参数类型中的`readonly`是为了可以接收`[1, '2', true] as const`这样的字面量元组；对于普通数组来说，也可以传给`readonly`数组。

关键的地方是`[...Tuple]`，这一次在类型推断时，`Tuple`的类型推断行为不再像上面一样，对整个数组使用`typeof`，而是对数组内的每一项使用`typeof`。

```ts
declare function fun<Tuple extends unknown[]>(tuple: readonly [...Tuple]): Tuple
fun([1, '2', true])
// function fun<[number, string, boolean]>(tuple: readonly [number, string, boolean]): [number, string, boolean]
```


