## 递归
```ts
MyAwaited
```
## 通过递归遍历元组

```ts
export type Includes<T extends readonly any[], U> = 
    T extends [infer first, ... infer res]
        // 注意，这里的first不能使用分布式
        ? [first] extends never
            ? false
            : Equal<first, U> extends true
                ? true
                : Includes<res, U>  
        : false
```

在上面中，需要特别注意，`first`在`extends`左边，如果是`Union`，则会开启分布式，不能开启分布式，否则就会出错。

举个例子：

```ts
type t = Includes<[boolean], true>

// 在“函数”内部，第一次，first为boolean
// boolean在处理时，会被当作true | false
// 因此如果这里不关闭分布式，带入值并且展开后，会变成下面的样子
// (
//    true extends never
//    ? false
//    : Equal<true, true> extends true
//      ? true
//      : false
//  ) | (
//    false extends never
//    ? false
//    : Equal<false, true> extends true
//      ? true
//      : false
//  )
// 最终的结果为true | false
```

其实，我这里这样写是因为想记录一下这个错误，因为我在第一次写的时候就犯了这个错误，我在这里想的是，递归到最后如果没有找到，`T`就变成了一个空的元组，这就导致了`first`成为`never`，可以通过这个条件结束递归，我这里是想处理这部分逻辑。

但其实，有更好的写法：

```ts
export type Includes<T extends readonly any[], U> =
    T extends [infer first, ... infer res]
    ? Equal<first, U> extends true
      ? true
      : Includes<res, U>
    : false
```

不需要处理`first`为`never`的情况，当`T`仅剩一个元素或者为空的时候，`res`为`never`，在下面的分支中，在调用`Includes<res, U>`时，`T extends [infer first, ...infer res]`会进入`false`分支，结束递归。
